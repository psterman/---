package com.example.aifloatingball.manager

import android.content.Context
import android.webkit.WebView
import com.example.aifloatingball.SettingsManager
import org.json.JSONArray
import org.json.JSONObject
import java.net.HttpURLConnection
import java.net.URL
import kotlinx.coroutines.*
import java.io.*
import android.os.Handler
import android.os.Looper
import android.util.Log
import com.google.gson.Gson

class ChatManager(private val context: Context) {
    private val settingsManager = SettingsManager.getInstance(context)
    private val scope = CoroutineScope(Dispatchers.IO + Job())
    private val chatHistory = mutableListOf<ChatMessage>()
    private var webViewRef: WebView? = null
    
    init {
        android.util.Log.d("ChatManager", "ChatManager 实例创建， context: $context, webViewRef: $webViewRef")
    }
    
    data class ChatMessage(
        val role: String,
        val content: String,
        val timestamp: Long = System.currentTimeMillis(),
        val isLoading: Boolean = false
    )

    companion object {
        private const val MAX_HISTORY_SIZE = 50
        private val HTML_TEMPLATE = """
            <!DOCTYPE html>
            <html>
            <head>
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <style>
                    body {
                        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
                        margin: 0;
                        padding: 8px;
                        background: #FFFFFF;
                        color: #2C3E50;
                        line-height: 1.6;
                    }
                    .header {
                        display: flex;
                        justify-content: center;
                        padding: 12px 0;
                        margin-bottom: 20px;
                        border-bottom: 1px solid #E0E0E0;
                    }
                    .logo {
                        height: 40px;
                        display: block;
                    }
                    .welcome-container {
                        text-align: center;
                        padding: 20px;
                        max-width: 600px;
                        margin: 0 auto 30px auto;
                    }
                    .welcome-title {
                        font-size: 24px;
                        font-weight: 600;
                        margin-bottom: 16px;
                        color: #2C3E50;
                    }
                    .welcome-text {
                        font-size: 16px;
                        color: #5D6D7E;
                        margin-bottom: 24px;
                    }
                    .example-queries {
                        background: #F8F9FA;
                        border-radius: 12px;
                        padding: 16px;
                        margin-bottom: 20px;
                    }
                    .example-title {
                        font-weight: 600;
                        margin-bottom: 12px;
                        color: #2C3E50;
                    }
                    .example-button {
                        display: inline-block;
                        background: #F1F3F4;
                        color: #2C3E50;
                        border: 1px solid #E0E0E0;
                        border-radius: 16px;
                        padding: 8px 16px;
                        margin: 4px;
                        font-size: 14px;
                        cursor: pointer;
                        transition: all 0.2s;
                    }
                    .example-button:hover {
                        background: #E1E5E8;
                    }
                    #messages {
                        max-width: 100%;
                        margin: 0 auto;
                        padding-bottom: 70px;
                    }
                    .message-container {
                        display: flex;
                        margin: 20px 0;
                        position: relative;
                    }
                    .avatar {
                        width: 36px;
                        height: 36px;
                        border-radius: 50%;
                        margin-right: 12px;
                        flex-shrink: 0;
                    }
                    .avatar.user {
                        background: #3498DB;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                    }
                    .avatar.assistant {
                        background: #F1F3F4;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }
                    .message-content {
                        flex: 1;
                        display: flex;
                        flex-direction: column;
                        max-width: calc(100% - 60px);
                    }
                    .message {
                        padding: 12px 16px;
                        border-radius: 12px;
                        word-wrap: break-word;
                        white-space: pre-wrap;
                        position: relative;
                        max-width: 100%;
                    }
                    .user-container .message {
                        background: #EBF5FE;
                        color: #2C3E50;
                        border: 1px solid #D4E6F9;
                    }
                    .assistant-container .message {
                        background: #F8F9FA;
                        border: 1px solid #E5E7EB;
                    }
                    .role-label {
                        font-size: 14px;
                        font-weight: 500;
                        color: #5D6D7E;
                        margin-bottom: 4px;
                    }
                    pre {
                        background: #2C3E50;
                        color: #E5E7EB;
                        padding: 12px;
                        border-radius: 8px;
                        overflow-x: auto;
                        margin: 8px 0;
                    }
                    code {
                        font-family: 'Consolas', 'Monaco', monospace;
                        font-size: 14px;
                    }
                    p {
                        margin: 8px 0;
                    }
                    ul, ol {
                        margin: 8px 0;
                        padding-left: 24px;
                    }
                    .copy-button {
                        position: absolute;
                        top: 8px;
                        right: 8px;
                        background: rgba(255,255,255,0.9);
                        border: 1px solid #E5E7EB;
                        border-radius: 4px;
                        padding: 4px 8px;
                        font-size: 12px;
                        cursor: pointer;
                        display: none;
                    }
                    .message-container:hover .copy-button {
                        display: block;
                    }
                    .typing-indicator {
                        display: inline-flex;
                        align-items: center;
                        margin-left: 8px;
                    }
                    .typing-indicator span {
                        height: 8px;
                        width: 8px;
                        background-color: #3498DB;
                        border-radius: 50%;
                        display: inline-block;
                        margin: 0 2px;
                        opacity: 0.4;
                        animation: typing 1s infinite;
                    }
                    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
                    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
                    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
                    @keyframes typing {
                        0% { opacity: 0.4; }
                        50% { opacity: 1; }
                        100% { opacity: 0.4; }
                    }
                    .error-message {
                        color: #D32F2F; /* Material Red 700 */
                        background-color: #FFEBEE; /* Material Red 50 */
                        border: 1px solid #EF9A9A; /* Material Red 200 */
                        padding: 12px;
                        margin: 10px auto;
                        border-radius: 8px;
                        font-size: 14px;
                        display: block; /* Ensure it's visible */
                        word-wrap: break-word;
                        max-width: 100%;
                        box-sizing: border-box; /* Include padding in the element's total width and height */
                    }
                    #input-area {
                        display: flex;
                        padding: 12px;
                        border-top: 1px solid #E5E7EB;
                        position: fixed;
                        bottom: 0;
                        left: 0;
                        right: 0;
                        background: #FFFFFF;
                        box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
                    }
                    #message-input {
                        flex-grow: 1;
                        padding: 12px 16px;
                        border: 1px solid #D1D5DB;
                        border-radius: 24px;
                        font-size: 16px;
                        outline: none;
                        transition: border 0.2s;
                    }
                    #message-input:focus {
                        border-color: #3498DB;
                    }
                    #send-button {
                        background: #3498DB;
                        color: white;
                        border: none;
                        border-radius: 50%;
                        width: 44px;
                        height: 44px;
                        margin-left: 10px;
                        cursor: pointer;
                        font-size: 16px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }
                </style>
            </head>
            <body>
                <div class="header">
                    <div class="logo">
                        <svg width="160" height="40" viewBox="0 0 160 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M20 6L6 34H34L20 6Z" fill="#3498DB"/>
                            <text x="48" y="25" font-family="Arial" font-size="18" font-weight="bold" fill="#2C3E50">DeepSeek</text>
                        </svg>
                    </div>
                </div>
                
                <div id="welcome-section" class="welcome-container">
                    <h1 class="welcome-title">欢迎使用 DeepSeek 智能助手</h1>
                    <p class="welcome-text">DeepSeek 是一个强大的 AI 助手，可以帮助你解决各种问题、进行创意写作、提供信息或只是聊天交流。</p>
                    
                    <div class="example-queries">
                        <div class="example-title">你可以尝试以下问题：</div>
                        <div class="example-button" onclick="useExample('如何提高英语口语水平？')">如何提高英语口语水平？</div>
                        <div class="example-button" onclick="useExample('写一个关于春天的短诗')">写一个关于春天的短诗</div>
                        <div class="example-button" onclick="useExample('解释量子计算的基本原理')">解释量子计算的基本原理</div>
                        <div class="example-button" onclick="useExample('帮我写一个简单的Python爬虫程序')">帮我写一个简单的Python爬虫程序</div>
                    </div>
                </div>
                
                <div id="messages"></div>
                <div id="status-message" class="error-message" style="display:none;"></div>
                
                <div id="input-area">
                    <div id="message-input" contenteditable="true" placeholder="输入你的消息..." inputmode="text" data-gramm="false"></div>
                    <button id="send-button" disabled>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" fill="white"/>
                        </svg>
                    </button>
                </div>
                
                <script>
                    let isGenerating = false;
                    const messageInput = document.getElementById('message-input');
                    const sendButton = document.getElementById('send-button');
                    const welcomeSection = document.getElementById('welcome-section');
                    const messagesContainer = document.getElementById('messages');
                    const statusMessageDiv = document.getElementById('status-message');
                    
                    function hideWelcomeSection() {
                        if (welcomeSection) {
                            welcomeSection.style.display = 'none';
                        }
                    }
                    
                    function useExample(text) {
                        messageInput.textContent = text;
                        // 移除了JS层面的focus，交由Native处理
                        // messageInput.focus();
                    }

                    function showErrorMessage(message) {
                        if (statusMessageDiv) {
                            statusMessageDiv.textContent = message;
                            statusMessageDiv.style.display = 'block';
                            messagesContainer.scrollTop = messagesContainer.scrollHeight; // Scroll to bottom
                        }
                    }

                    function hideErrorMessage() {
                        if (statusMessageDiv) {
                            statusMessageDiv.style.display = 'none';
                            statusMessageDiv.textContent = '';
                        }
                    }
                    
                    function showTypingIndicator() {
                        hideErrorMessage(); // Hide any previous error message
                        const lastAssistantMessage = messagesContainer.lastElementChild;
                        if (lastAssistantMessage && lastAssistantMessage.classList.contains('assistant-container')) {
                            let typingDiv = lastAssistantMessage.querySelector('.typing-indicator');
                            if (!typingDiv) {
                                typingDiv = document.createElement('div');
                                typingDiv.className = 'typing-indicator';
                                typingDiv.innerHTML = '<span></span><span></span><span></span>';
                                lastAssistantMessage.querySelector('.message-content').appendChild(typingDiv);
                            }
                            typingDiv.style.display = 'inline-flex';
                        }
                    }

                    function removeTypingIndicator() {
                        const typingDiv = messagesContainer.querySelector('.typing-indicator');
                        if (typingDiv) {
                            typingDiv.style.display = 'none';
                        }
                    }
                    
                    function addMessageToUI(role, content, isComplete = true) {
                        hideWelcomeSection();
                        hideErrorMessage(); // Hide error message when new message comes
                        const messageContainer = document.createElement('div');
                        messageContainer.className = 'message-container ' + role + '-container';

                        const avatar = document.createElement('div');
                        avatar.className = 'avatar ' + role;
                        avatar.textContent = role === 'user' ? '你' : 'AI';

                        const messageContentDiv = document.createElement('div');
                        messageContentDiv.className = 'message-content';

                        const roleLabel = document.createElement('div');
                        roleLabel.className = 'role-label';
                        roleLabel.textContent = role === 'user' ? '你' : 'AI';
                        messageContentDiv.appendChild(roleLabel);

                        const messageDiv = document.createElement('div');
                        messageDiv.className = 'message';
                        messageDiv.innerHTML = markdownToHtml(content);
                        messageContentDiv.appendChild(messageDiv);

                        if (role === 'assistant' && !isComplete) {
                            let typingDiv = document.createElement('div');
                            typingDiv.className = 'typing-indicator';
                            typingDiv.innerHTML = '<span></span><span></span><span></span>';
                            messageContentDiv.appendChild(typingDiv);
                        }

                        messageContainer.appendChild(avatar);
                        messageContainer.appendChild(messageContentDiv);
                        messagesContainer.appendChild(messageContainer);
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        updateSendButton();
                    }

                    // This function will be called for streaming updates
                    function updateLastAssistantMessage(newContent) {
                        const lastAssistantMessageDiv = messagesContainer.lastElementChild?.querySelector('.assistant-container .message');
                        if (lastAssistantMessageDiv) {
                            lastAssistantMessageDiv.innerHTML = markdownToHtml(newContent);
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        }
                    }

                    // This function will be called when the response is complete
                    function completeResponse() {
                        removeTypingIndicator();
                        isGenerating = false;
                        updateSendButton();
                        messagesContainer.scrollTop = messagesContainer.scrollHeight; // Ensure scroll to bottom
                    }

                    document.getElementById('send-button').addEventListener('click', function() {
                        sendMessage();
                    });

                    document.getElementById('message-input').addEventListener('keydown', function(e) {
                        if ((e.key === 'Enter' || e.keyCode === 13) && !e.shiftKey) {
                            e.preventDefault();
                            sendMessage();
                            return false;
                        }
                    });

                    function sendMessage() {
                        var messageText = messageInput.textContent.trim();
                        if (messageText) {
                            isGenerating = true;
                            addMessageToUI('user', messageText); // Add user message
                            // Add assistant placeholder with typing indicator
                            addMessageToUI('assistant', '', false);
                            showTypingIndicator(); // Show typing indicator
                            AndroidChatInterface.sendMessage(messageText);
                            messageInput.textContent = ''; // 清空输入框
                            updateSendButton();
                        }
                    }
                    
                    // markdownToHtml function (assuming this exists or will be added)
                    function markdownToHtml(markdown) {
                        // A simple markdown to HTML conversion for demonstration
                        // For production, consider a robust markdown library
                        let html = markdown
                            .replace(/```(.*?)```/gs, function(match, p1) { return '<pre><code>' + escapeHtml(p1.trim()) + '</code></pre>'; })
                            .replace(/`(.*?)`/g, function(match, p1) { return '<code>' + escapeHtml(p1) + '</code>'; })
                            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                            .replace(/\*(.*?)\*/g, '<em>$1</em>')
                            .replace(/^- (.*)/gm, '<li>$1</li>')
                            .replace(/\\n/g, '<br/>'); // Handle \\n to <br/> for display

                        // Simple list conversion for ordered lists (needs more robust handling for nested lists)
                        let listItems = html.match(/^\d+\. (.*)$/gm);
                        if (listItems) {
                            html = html.replace(/^\d+\. (.*)$/gm, '<li>$1</li>');
                            if (!html.includes('<ol>')) {
                                html = '<ol>' + html + '</ol>';
                            }
                        }
                        return html;
                    }

                    // 功能：更新发送按钮状态
                    function updateSendButton() {
                        const text = messageInput.textContent.trim();
                        sendButton.disabled = text === '' || isGenerating;
                    }

                    // 功能：加载聊天历史记录
                    function loadChatHistory() {
                        // Placeholder for loading history from Android (if implemented)
                        // Example: const historyJson = AndroidChatInterface.loadHistory();
                        // if (historyJson) { chatHistory = JSON.parse(historyJson); }
                        // renderHistoryList();
                    }

                    // 功能：保存聊天历史记录
                    function saveChatHistory() {
                        // Placeholder for saving history to Android (if implemented)
                        // Example: AndroidChatInterface.saveHistory(JSON.stringify(chatHistory));
                    }

                    // 功能：渲染历史记录列表
                    function renderHistoryList() {
                        // Placeholder for rendering history UI
                    }

                    // 功能：切换历史记录面板
                    // historyBtn.addEventListener('click', function () { /* ... */ });

                    // 功能：创建新对话
                    // newChatBtn.addEventListener('click', function () { /* ... */ });

                    // 功能：开始新对话 (Keep this function if it's called from Android)
                    function startNewChat() {
                        // currentChatId = Date.now().toString(); // Manage chat IDs if needed
                        messagesContainer.innerHTML = '';
                        hideErrorMessage();
                        // Reset other UI elements as needed for a new chat
                        messageInput.textContent = '';
                        updateSendButton();
                        // AndroidChatInterface.startNewChatInAndroid(); // Notify Android to clear its history
                    }

                    // 功能：加载指定ID的聊天
                    function loadChat(chatId) {
                        // Placeholder for loading specific chat history
                    }

                    // If no history, start a new chat (initial load)
                    // This logic might be better controlled from the Android side
                    // if (chatHistory.length === 0) {
                    //     startNewChat();
                    // } else {
                    //     const recentChat = [...chatHistory].sort((a, b) => b.timestamp - a.timestamp)[0];
                    //     if (recentChat) {
                    //         loadChat(recentChat.id);
                    //     }
                    // }

                    function escapeHtml(unsafe) {
                        return unsafe
                            .replace(/&/g, "&amp;")
                            .replace(/</g, "&lt;")
                            .replace(/>/g, "&gt;")
                            .replace(/"/g, "&quot;")
                            .replace(/'/g, "&#039;");
                    }

                </script>
            </body>
            </html>
        """

        // 添加公共方法来获取HTML模板
        fun getChatHtmlTemplate(): String {
            return HTML_TEMPLATE
        }
    }

    fun initWebView(webView: WebView) {
        this.webViewRef = webView // Ensure webViewRef is set
        webView.settings.javaScriptEnabled = true
        webView.settings.domStorageEnabled = true
        webView.settings.databaseEnabled = true
        webView.settings.allowFileAccess = true
        webView.settings.allowContentAccess = true
        
        // 确保WebView可以获得焦点并显示软键盘
        webView.isFocusable = true
        webView.isFocusableInTouchMode = true
        webView.requestFocus()
        
        // 添加JavaScript接口 - 确保移除旧的接口以避免重复添加
        try {
            webView.removeJavascriptInterface("AndroidChatInterface")
        } catch (e: Exception) {
            Log.d("ChatManager", "No previous interface to remove: ${e.message}")
        }
        
        // 添加新的JavaScript接口
        webView.addJavascriptInterface(AndroidChatInterface(), "AndroidChatInterface")
        Log.d("ChatManager", "AndroidChatInterface 已添加到 WebView")
        
        // 清空聊天历史，确保新会话
        chatHistory.clear()
        
        // 加载HTML内容而不是文件 - 更可靠
        webView.loadDataWithBaseURL("https://deepseek.ai", HTML_TEMPLATE, "text/html", "UTF-8", null)
        
        // 设置网页加载完成的监听器
        webView.webViewClient = object : android.webkit.WebViewClient() {
            override fun onPageFinished(view: WebView?, url: String?) {
                super.onPageFinished(view, url)
                Log.d("ChatManager", "DeepSeek Chat 网页加载完成")
                // 确保重置界面状态
                Handler(Looper.getMainLooper()).post {
                    webView.evaluateJavascript("document.getElementById('message-input').textContent = '';", null)
                    webView.evaluateJavascript("updateSendButton();", null)
                }
            }
            
            override fun onReceivedError(view: WebView?, errorCode: Int, description: String?, failingUrl: String?) {
                super.onReceivedError(view, errorCode, description, failingUrl)
                Log.e("ChatManager", "WebView 加载错误: $errorCode, $description")
            }
        }
    }

    // Android 端与 WebView JavaScript 交互的接口
    private inner class AndroidChatInterface {
        @android.webkit.JavascriptInterface
        fun sendMessage(message: String) {
            Log.d("ChatManager", "从 JavaScript 接收到消息: $message")
            // 确保消息不为空
            if (message.trim().isEmpty()) {
                Log.w("ChatManager", "收到空消息，不处理")
                return
            }
            
            // 在主线程上处理消息发送
            Handler(Looper.getMainLooper()).post { 
                webViewRef?.let { wv ->
                    val isDeepSeek = true // Assuming this is always DeepSeek for this specific WebView
                    Log.d("ChatManager", "调用 sendMessageToWebView 发送消息: $message, isDeepSeek: $isDeepSeek")
                    sendMessageToWebView(message, wv, isDeepSeek)
                } ?: run {
                    Log.e("ChatManager", "webViewRef 为空，无法发送消息")
                    // 尝试恢复 - 使用上下文查找WebView
                    if (context is com.example.aifloatingball.service.DualFloatingWebViewService) {
                        val service = context as com.example.aifloatingball.service.DualFloatingWebViewService
                        val webView = service.webViewManager.getWebViews().firstOrNull()
                        webView?.let { wv ->
                            Log.d("ChatManager", "已恢复WebView引用，重新发送消息")
                            this@ChatManager.webViewRef = wv
                            sendMessageToWebView(message, wv, true)
                        }
                    }
                }
            }
        }

        @android.webkit.JavascriptInterface
        fun getChatHistoryJson(): String {
            return Gson().toJson(chatHistory)
        }

        @android.webkit.JavascriptInterface
        fun clearChatHistory() {
            chatHistory.clear()
            Handler(Looper.getMainLooper()).post {
                webViewRef?.evaluateJavascript("startNewChat();", null) // Reset WebView UI
            }
        }
    }

    private fun constructJsonMessages(): JSONArray {
        val jsonArray = JSONArray()
        
        // 添加系统消息
        val systemMsg = JSONObject().apply {
            put("role", "system")
            put("content", "You are DeepSeek, a helpful AI assistant. Respond in the same language as the user's message.")
        }
        jsonArray.put(systemMsg)
        
        // 添加聊天历史
        chatHistory.forEach { message ->
            val msgObject = JSONObject().apply {
                // 确保角色是 API 支持的类型
                val role = when(message.role) {
                    "user" -> "user"
                    "assistant" -> "assistant"
                    else -> "user" // 默认作为用户消息
                }
                put("role", role)
                put("content", message.content)
            }
            jsonArray.put(msgObject)
        }
        
        Log.d("ChatManager", "构建的消息数组: $jsonArray")
        return jsonArray
    }

    fun sendMessageToWebView(message: String, webView: WebView, isDeepSeek: Boolean) {
        this.webViewRef = webView // Ensure webViewRef is up-to-date
        
        Log.d("ChatManager", "sendMessageToWebView called: message=$message, isDeepSeek=$isDeepSeek")
        
        if (isDeepSeek) {
            val apiKey = settingsManager.getDeepSeekApiKey()
            Log.d("ChatManager", "DeepSeek API Key: ${apiKey?.take(5)}...")
            
            if (apiKey.isNullOrBlank()) {
                Handler(Looper.getMainLooper()).post {
                    webView.evaluateJavascript("showErrorMessage('DeepSeek API 密钥未设置。请在设置中配置您的API密钥。');", null)
                    webView.evaluateJavascript("removeTypingIndicator();", null)
                    webView.evaluateJavascript("completeResponse();", null)
                }
                return
            }
        } else {
            if (settingsManager.getChatGPTApiKey().isNullOrBlank()) {
                Handler(Looper.getMainLooper()).post {
                    webView.evaluateJavascript("showErrorMessage('ChatGPT API 密钥未设置。请在设置中配置您的API密钥。');", null)
                    webView.evaluateJavascript("removeTypingIndicator();", null)
                    webView.evaluateJavascript("completeResponse();", null)
                }
                return
            }
        }

        val userMessage = ChatMessage("user", message)
        chatHistory.add(userMessage)
        
        Log.d("ChatManager", "添加用户消息到历史记录: $message")
        
        // Add assistant placeholder with typing indicator in UI
        Handler(Looper.getMainLooper()).post {
            // Note: addMessageToUI for assistant with isComplete=false will add typing indicator
            // However, the JS part calls AndroidChatInterface.sendMessage() which is on main thread,
            // so we add the user message there. The assistant message should be added here *before* the API call.
            // Let's refine the JS to add user message first, then Android adds assistant placeholder.
            // But the current JS already adds user message and then calls Android.
            // So Android should add the assistant placeholder, then make the API call.
            webView.evaluateJavascript("addMessageToUI('assistant', '', false);", null)
            webView.evaluateJavascript("showTypingIndicator();", null)
            webView.evaluateJavascript("hideWelcomeSection();", null); // Hide welcome section if a message is sent
        }

        scope.launch {
            try {
                val response: String
                if (isDeepSeek) {
                    // This call will stream updates directly to WebView via evaluateJavascript
                    response = callDeepSeekApi(constructJsonMessages())
                } else {
                    // For non-streaming APIs like old ChatGPT (if applicable)
                    response = sendToChatGPT(chatHistory)
                }

                // If streaming, the UI is updated incrementally.
                // Here, we just ensure the last message is finalized and indicator removed.
                val finalAssistantMessageContent = if (isDeepSeek) {
                    // For streaming, the content is already updated. Just add to history with final content.
                    (chatHistory.lastOrNull { it.role == "assistant" }?.content ?: response) // Use content from JS or fall back
                } else {
                    response
                }
                chatHistory.add(ChatMessage("assistant", finalAssistantMessageContent))

                // Ensure UI is finalized on main thread
                withContext(Dispatchers.Main) {
                    // Call completeResponse to ensure typing indicator is removed
                    // and other final UI adjustments are made.
                    // For streaming, updateLastAssistantMessage is called inside callDeepSeekApi
                    if (!isDeepSeek) { // Only update final content if not streaming
                        webView.evaluateJavascript("updateLastAssistantMessage('" + escapeHtml(finalAssistantMessageContent) + "');", null)
                    }
                    webView.evaluateJavascript("completeResponse();", null)
                }

            } catch (e: Exception) {
                Log.e("ChatManager", "Error in AI response: ${e.message}", e)
                val errorMessage = "AI 响应失败：${e.localizedMessage ?: e.message ?: "未知错误"}"
                // Display error message in WebView
                withContext(Dispatchers.Main) {
                    webView.evaluateJavascript("showErrorMessage('" + escapeHtml(errorMessage) + "');", null)
                    webView.evaluateJavascript("removeTypingIndicator();", null) // Hide typing indicator on error
                    webView.evaluateJavascript("completeResponse();", null) // Mark as complete (even if error)
                }
                chatHistory.add(ChatMessage("assistant", errorMessage)) // Add error to history
            } finally {
                // Ensure typing indicator is removed even if there's an unexpected error or early exit
                withContext(Dispatchers.Main) {
                    webView.evaluateJavascript("removeTypingIndicator();", null)
                    webView.evaluateJavascript("completeResponse();", null) // Double check completion
                }
                if (chatHistory.size > MAX_HISTORY_SIZE) {
                    chatHistory.removeAt(0)
                }
            }
        }
    }

    private suspend fun sendToChatGPT(messages: MutableList<ChatMessage>): String {
        val apiKey = settingsManager.getChatGPTApiKey()
        val apiUrl = settingsManager.getChatGPTApiUrl()

        if (apiKey.isBlank()) {
            return "错误：ChatGPT API 密钥未设置。请在设置中配置您的API密钥。"
        }

        val url = URL(apiUrl)
        var connection: HttpURLConnection? = null
        try {
            connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "POST"
            connection.setRequestProperty("Content-Type", "application/json")
            connection.setRequestProperty("Authorization", "Bearer $apiKey")
            connection.doOutput = true

            val jsonMessages = JSONArray()
            messages.forEach { msg ->
                val msgObject = JSONObject().apply {
                    put("role", msg.role)
                    put("content", msg.content)
                }
                jsonMessages.put(msgObject)
            }

            val jsonInputString = JSONObject().apply {
                put("model", "gpt-3.5-turbo") // You can make this configurable
                put("messages", jsonMessages)
            }.toString()

            connection.outputStream.use { os ->
                val input = jsonInputString.toByteArray(Charsets.UTF_8)
                os.write(input, 0, input.size)
            }

            val responseCode = connection.responseCode
            Log.d("ChatManager", "ChatGPT API 响应码: $responseCode")

            if (responseCode == HttpURLConnection.HTTP_OK) {
                BufferedReader(InputStreamReader(connection.inputStream, Charsets.UTF_8)).use { br ->
                    val response = StringBuilder()
                    var responseLine: String?
                    while (br.readLine().also { responseLine = it } != null) {
                        response.append(responseLine!!.trim())
                    }
                    val jsonResponse = JSONObject(response.toString())
                    val choices = jsonResponse.optJSONArray("choices")
                    return if (choices != null && choices.length() > 0) {
                        val message = choices.getJSONObject(0).optJSONObject("message")
                        message?.optString("content") ?: "未能获取到AI的回复。"
                    } else {
                        "未能获取到AI的回复。"
                    }
                }
            } else {
                val errorStream = connection.errorStream
                val reader = BufferedReader(InputStreamReader(errorStream, Charsets.UTF_8))
                val errorResponse = reader.readText()
                Log.e("ChatManager", "ChatGPT API 错误响应 ($responseCode): $errorResponse")
                return "ChatGPT API 请求失败 (${responseCode}): $errorResponse"
            }
        } catch (e: Exception) {
            Log.e("ChatManager", "ChatGPT API 网络请求错误: ${e.message}", e)
            return "ChatGPT API 网络请求失败：${e.localizedMessage}"
        } finally {
            connection?.disconnect()
        }
    }

    private fun escapeHtml(unsafe: String): String {
        return unsafe
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&#039;")
    }

    // Helper to get DeepSeek model based on settings if needed
    private fun getDeepSeekModel(): String {
        return "deepseek-chat" // Or retrieve from settings if configurable
    }
    
    /**
     * Call DeepSeek API with streaming response.
     * @param messages JSON array of messages to send to the API
     * @return Final response string
     */
    private suspend fun callDeepSeekApi(messages: JSONArray): String {
        val apiKey = settingsManager.getDeepSeekApiKey() ?: ""
        if (apiKey.isBlank()) {
            return "错误：DeepSeek API 密钥未设置。请在设置中配置您的API密钥。"
        }
        
        val apiUrl = "https://api.deepseek.ai/v1/chat/completions"
        val model = getDeepSeekModel()
        var connection: HttpURLConnection? = null
        val responseContent = StringBuilder()
        var retryCount = 0
        val maxRetries = 2
        
        Log.d("ChatManager", "正在调用 DeepSeek API，消息内容: $messages")
        
        while (retryCount <= maxRetries) {
            try {
                val url = URL(apiUrl)
                connection = url.openConnection() as HttpURLConnection
                connection.requestMethod = "POST"
                connection.setRequestProperty("Content-Type", "application/json")
                connection.setRequestProperty("Authorization", "Bearer $apiKey")
                connection.setRequestProperty("Accept", "text/event-stream")
                connection.connectTimeout = 30000  // 30秒连接超时
                connection.readTimeout = 60000    // 60秒读取超时
                connection.doOutput = true
                
                val jsonInputString = JSONObject().apply {
                    put("model", model)
                    put("messages", messages)
                    put("stream", true)
                    put("temperature", 0.7)
                    put("max_tokens", 2000)
                }.toString()
                
                Log.d("ChatManager", "发送到 DeepSeek 的请求体: $jsonInputString")
                
                connection.outputStream.use { os ->
                    val input = jsonInputString.toByteArray(Charsets.UTF_8)
                    os.write(input, 0, input.size)
                }
                
                Log.d("ChatManager", "请求已发送到 DeepSeek API")
                
                val responseCode = connection.responseCode
                Log.d("ChatManager", "DeepSeek API 响应码: $responseCode")
                
                if (responseCode == HttpURLConnection.HTTP_OK) {
                    BufferedReader(InputStreamReader(connection.inputStream, Charsets.UTF_8)).use { reader ->
                        var line: String?
                        var emptyLineCount = 0
                        val maxEmptyLines = 5
                        
                        while (reader.readLine().also { line = it } != null) {
                            // 检测连续空行，可能表示连接问题
                            if (line.isNullOrBlank()) {
                                emptyLineCount++
                                if (emptyLineCount > maxEmptyLines) {
                                    Log.w("ChatManager", "检测到多个连续空行，可能存在连接问题")
                                    break
                                }
                                continue
                            } else {
                                emptyLineCount = 0 // 重置计数器
                            }
                            
                            if (line!!.startsWith("data:") && !line!!.contains("data: [DONE]")) {
                                try {
                                    val jsonString = line!!.substring(5).trim()
                                    // Skip empty lines
                                    if (jsonString.isEmpty()) {
                                        continue
                                    }
                                    
                                    // Handle special case of [DONE]
                                    if (jsonString == "[DONE]") {
                                        Log.d("ChatManager", "DeepSeek stream finished with [DONE]")
                                        break
                                    }
                                    
                                    // Log the raw JSON for debugging
                                    Log.d("ChatManager", "Raw JSON chunk: $jsonString")
                                    
                                    // Safely parse JSON
                                    try {
                                        val jsonResponse = JSONObject(jsonString)
                                        val choices = jsonResponse.optJSONArray("choices")
                                        if (choices != null && choices.length() > 0) {
                                            val delta = choices.getJSONObject(0).optJSONObject("delta")
                                            if (delta != null) {
                                                val content = delta.optString("content", "")
                                                if (content.isNotEmpty()) {
                                                    Log.d("ChatManager", "Received content chunk: $content")
                                                    responseContent.append(content)
                                                    // Update UI on main thread with current accumulated content
                                                    withContext(Dispatchers.Main) {
                                                        webViewRef?.evaluateJavascript(
                                                            "updateLastAssistantMessage('${escapeHtml(responseContent.toString())}');",
                                                            null
                                                        )
                                                    }
                                                }
                                            }
                                        }
                                    } catch (jsonEx: Exception) {
                                        Log.e("ChatManager", "JSON parsing error: ${jsonEx.message}, line: $jsonString", jsonEx)
                                        // Ignore this chunk and continue with next one
                                    }
                                } catch (e: Exception) {
                                    Log.e("ChatManager", "Error processing stream response: ${e.message}, line: ${line}", e)
                                    // Continue processing even if one chunk has an error
                                    continue
                                }
                            } else if (line!!.contains("[DONE]")) {
                                Log.d("ChatManager", "DeepSeek stream finished.")
                                break // 正常结束
                            } else {
                                Log.d("ChatManager", "Unhandled stream line: $line")
                            }
                        }
                    }
                    
                    // 成功获取到响应，跳出重试循环
                    break
                } else {
                    val errorStream = connection.errorStream
                    val reader = BufferedReader(InputStreamReader(errorStream, Charsets.UTF_8))
                    val errorResponse = reader.readText()
                    Log.e("ChatManager", "DeepSeek API 错误响应 ($responseCode): $errorResponse")
                    
                    if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
                        return "DeepSeek API 认证失败，请检查您的 API 密钥。"
                    }
                    
                    // 对于服务器错误，尝试重试
                    if (responseCode >= 500 && retryCount < maxRetries) {
                        retryCount++
                        Log.w("ChatManager", "服务器错误，尝试第 $retryCount 次重试...")
                        Thread.sleep(1000 * retryCount) // 指数退避，使用Thread.sleep替代delay
                        continue
                    }
                    
                    return "DeepSeek API 请求失败 (${responseCode}): $errorResponse"
                }
            } catch (e: Exception) {
                Log.e("ChatManager", "DeepSeek API 网络请求错误: ${e.message}", e)
                
                // 对于网络错误，尝试重试
                if (retryCount < maxRetries) {
                    retryCount++
                    Log.w("ChatManager", "网络错误，尝试第 $retryCount 次重试...")
                    Thread.sleep(1000 * retryCount) // 指数退避，使用Thread.sleep替代delay
                    continue
                }
                
                return "DeepSeek API 网络请求失败：${e.localizedMessage ?: e.message ?: "未知错误"}"
            } finally {
                connection?.disconnect()
            }
        }
        
        // 处理最终响应
        val finalResponse = responseContent.toString()
        if (finalResponse.isBlank()) {
            Log.w("ChatManager", "Final DeepSeek response content is blank. Returning fallback message.")
            return "抱歉，DeepSeek 未能生成有效回复。请稍后再试。"
        }
        
        Log.d("ChatManager", "Complete response content: $finalResponse")
        return finalResponse
    }

    /**
     * Send a message to the AI and get a response
     * @param message The user message to send
     * @param isDeepSeek Whether to use DeepSeek or ChatGPT
     * @return The AI response
     */
    suspend fun sendMessage(message: String, isDeepSeek: Boolean): String {
        // Create a user message
        val userMessage = ChatMessage("user", message)
        chatHistory.add(userMessage)
        
        try {
            // Get the response based on the selected AI service
            val response = if (isDeepSeek) {
                callDeepSeekApi(constructJsonMessages())
            } else {
                sendToChatGPT(chatHistory)
            }
            
            // Add the assistant response to chat history
            chatHistory.add(ChatMessage("assistant", response))
            
            // Return the response
            return response
            
        } catch (e: Exception) {
            Log.e("ChatManager", "Error in sendMessage: ${e.message}", e)
            val errorMessage = "AI 响应失败：${e.localizedMessage ?: e.message ?: "未知错误"}"
            chatHistory.add(ChatMessage("assistant", errorMessage))
            throw e
        } finally {
            // Trim chat history if it gets too large
            if (chatHistory.size > MAX_HISTORY_SIZE) {
                chatHistory.removeAt(0)
            }
        }
    }
}